\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_accord_l_d_a_model}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+Accord\+LDAModel}} \\*LDA predictor using model from ACCORD.\+NET library }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_accord_l_d_a_model}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_accord_s_v_m_gaussian_model}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+Accord\+SVMGaussian\+Model}} \\*SVM predictor with gaussian kernel using model from ACCORD.\+NET library }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_accord_s_v_m_gaussian_model}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_accord_s_v_m_linear_model}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+Accord\+SVMLinear\+Model}} \\*SVM predictor with gaussian kernel using model from ACCORD.\+NET library }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_accord_s_v_m_linear_model}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_data_logger}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Data\+Logging.\+Data\+Logger}} \\*Creates an object that runs on it\textquotesingle{}s own thread to manage data collection at reliable time intervals }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_data_logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_data_manager}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+Data\+Manager}} \\*class to hold all information from a data recording session }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_data_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_o_n_n_x_model_1_1_dynamic_input_type}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+ONNXModel.\+Dynamic\+Input\+Type$<$ T $>$}} \\*ML.\+Net requires a user defined class for input data }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_o_n_n_x_model_1_1_dynamic_input_type}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_o_n_n_x_model_1_1_dynamic_output_type}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+ONNXModel.\+Dynamic\+Output\+Type$<$ T $>$}} \\*ML.\+net requires a user defined class for output data"{} }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_o_n_n_x_model_1_1_dynamic_output_type}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_examples_1_1_examples}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Examples.\+Examples}} \\*Here are example code snippets for each main item in the \mbox{\hyperlink{namespace_e_m_g___pattern_rec___c_s}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS}} library }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_examples_1_1_examples}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_features}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Mapping.\+Features}} \\*static class of window based feature mapping methods for time series data structured as Lists }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_features}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_filters}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Mapping.\+Filters}} \\*static class of various filter techniques using the NWaves library for preprocessing signals }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_filters}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_i_predictor}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+IPredictor}} \\*Predictor interface to standardize implemented predictors }{\pageref{interface_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_i_predictor}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_mapper}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Mapping.\+Mapper}} \\*utilizes \mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_scalers}{Scalers}}, \mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_features}{Features}}, and \mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_filters}{Filters}} functions to create a pipeline mapping raw input signals to features }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_mapper}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_model}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+Model}} \\*class to hold all pattern recognition model information and capabilities }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_model}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_obj_logger}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Data\+Logging.\+Obj\+Logger}} \\*uses Newtonsoft.\+json to serialize and deserialize objects }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_obj_logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_o_n_n_x_model}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+ONNXModel}} \\*holds a pre-\/trained Open Neural Network e\+Xchange model and provides some simple functionality to manipulate input and output data }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_o_n_n_x_model}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_post_processor}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Mapping.\+Post\+Processor}} \\*class to hold all post processing techniques }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_post_processor}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_p_r___logger}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Data\+Logging.\+PR\+\_\+\+Logger}} \\*class derived from regular \mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_data_logger}{Data\+Logger}} class to facilitate data collection for pattern recognition with ground truth labels }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_data_logging_1_1_p_r___logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_real_time_model}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Pattern\+Rec.\+Real\+Time\+Model}} \\*Enables consistent real-\/time prediction from a \mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_model}{Model}} object at the specified frequency it was trained on. Inherits from Data\+Logger class }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_pattern_rec_1_1_real_time_model}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_scalers}{EMG\+\_\+\+Pattern\+Rec\+\_\+\+CS.\+Mapping.\+Scalers}} \\*static class of various scaling techniques for preprocessing data. These functions are designed for use with the \char`\"{}scaler\+\_\+pipeline\+\_\+func\char`\"{} delegate. since the information required(min\+\_\+values, max\+\_\+values, and mean\+\_\+values) will change after each function is performed, only one of these functions should be called }{\pageref{class_e_m_g___pattern_rec___c_s_1_1_mapping_1_1_scalers}}{}
\end{DoxyCompactList}
